using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Models;
using DataAccessLayer;
using SchedulingEngine;
using MedSchedulerFinal.Utilitys;

namespace Testing
{
    class Program
    {

      public static void PrintPatientDetailes(Patient p)
        {
            if (p == null) { /*...*/ return; }
            Console.WriteLine("============================");
            Console.WriteLine("      Patient Details");
            Console.WriteLine("----------------------------");
            Console.WriteLine($"Patient ID: {p.Id}");
            Console.WriteLine($"Name: {p.Name ?? "N/A"}");
            Console.WriteLine($"Condition: {p.Condition ?? "N/A"}");
            Console.WriteLine($"Urgency: {p.Urgency}");
            Console.WriteLine($"Complexity: {p.ComplexityLevel}");
            Console.WriteLine($"Required Spec: {p.RequiredSpecialization ?? "N/A"}");
            Console.WriteLine($"Est. Duration: {p.EstimatedAppointmentDuration.TotalMinutes} mins"); // Added Duration
            Console.WriteLine();
        }

        // --- NEW/UPDATED METHODS FOR HANDLING RESULTS ---

        /// <summary>
        /// Updates the AssignedDoctorId property on Patient objects based on the final schedule.
        /// Uses the new Schedule object containing ScheduledAppointment list and lookups.
        /// </summary>
        /// <param name="schedule">The final schedule generated by the algorithm.</param>
        private static void UpdatePatientAssignmentsFromSchedule(Schedule schedule)
        {
            List<Patient> allPatients = null; // Assuming singleton holds the list
            if (schedule == null || allPatients == null)
            {
                Console.WriteLine("WARN: Cannot update patient assignments, schedule or patient list is null.");
                return;
            }

            Console.WriteLine("Updating Patient AssignedDoctorId based on schedule...");
            int updatedCount = 0;
            int clearedCount = 0;

            foreach (var patient in allPatients)
            {
                // Check if this patient has an assignment in the final schedule's lookup
                if (schedule.PatientAssignmentLookup.TryGetValue(patient.Id, out ScheduledAppointment appointment))
                {
                    // Patient IS assigned in the schedule.
                    // Apply logic similar to before regarding surgery patients if needed.
                    if (!patient.NeedsSurgery || !patient.AssignedSurgeonId.HasValue) // Assign if not surgery OR if surgery but no surgeon yet
                    {
                        if (patient.AssignedDoctorId != appointment.DoctorId)
                        {
                            patient.AssignedDoctorId = appointment.DoctorId;
                            updatedCount++;
                        }
                        // Optional: Store full appointment details if you added a property to Patient class
                        // patient.AssignedAppointmentDetails = appointment;
                    }
                    // Else: Patient needs surgery AND already has a surgeon assigned, don't overwrite with GA doctor.
                }
                else
                {
                    // Patient is NOT assigned in the schedule.
                    // Clear assignment ONLY if they don't need surgery OR need surgery but lack a surgeon.
                    if (!patient.NeedsSurgery || !patient.AssignedSurgeonId.HasValue)
                    {
                        if (patient.AssignedDoctorId != null)
                        {
                            patient.AssignedDoctorId = null;
                            // patient.AssignedAppointmentDetails = null; // Clear details if stored
                            clearedCount++;
                        }
                    }
                }
            }
            Console.WriteLine($"Patient assignments updated: {updatedCount} assigned/changed, {clearedCount} cleared.");
        }

        /// <summary>
        /// Updates the Workload (and optionally patient list) on Doctor objects in the Singleton
        /// based on the final generated schedule.
        /// </summary>
        /// <param name="bestSchedule">The final schedule from Solve().</param>
        //private static async Task UpdateSingeletonData(Schedule bestSchedule)
        //{

        //    if (bestSchedule == null)
        //    {
        //        Console.WriteLine("WARN: Cannot update singleton data, best schedule is null.");
        //        return; // Handle null schedule
        //    }

        //    Console.WriteLine("Updating Doctor workloads based on final schedule...");
        //    // Update Doctor Workloads and potentially their patient lists
        //    foreach (var doctor in Doctors)
        //    {
        //        if (bestSchedule.DoctorAssignmentLookup.TryGetValue(doctor.Id, out var assignedAppointments))
        //        {
        //            // Set workload directly from the count of appointments in the final schedule
        //            doctor.Workload = assignedAppointments.Count;
        //            // OPTIONAL: Update the doctor's list of assigned patient IDs if still needed elsewhere.
        //            // Otherwise, this list might be redundant now.
        //            doctor.patientsIDS = assignedAppointments.Select(a => a.PatientId).ToList();
        //        }
        //        else
        //        {
        //            // Doctor has no assignments in the final schedule
        //            doctor.Workload = 0;
        //            doctor.patientsIDS = new List<int>();
        //        }
        //        // Remove the call to doctor.SetCurrentWorkLoad() if workload is set directly here.
        //    }

        //    // Update Patient assignments using the new schedule structure
        //    UpdatePatientAssignmentsFromSchedule(bestSchedule); // Call the updated method

        //    // If this method must be async but has no awaits, return CompletedTask
        //    await Task.CompletedTask;
        //}

        //static async Task Main(string[] args)
        //{

        //    SharedState data = new SharedState();
        //    // --- Data Loading ---
        //    Console.WriteLine("Loading data...");
        //    // Ensure your connection string is correctly passed or configured
        //    string connectionString = "server=localhost;port=3306;database=medscheduler;user=root;password=LuffyDono2005;"; // Replace with your actual connection string
        //    DoctorRepository docs = new DoctorRepository(connectionString);
        //    PatientRepository pat = new PatientRepository(connectionString);

        //    List<Doctor> Doctors = await docs.GetAllWithDetailsAsync();
        //    List<Patient> Patients = await pat.GetAllAsync();
        //    Console.WriteLine($"Loaded {Doctors.Count} doctors, {Patients.Count} patients.");
        //    if (!Doctors.Any() || !Patients.Any())
        //    {
        //        Console.WriteLine("Error: No doctors or patients loaded. Exiting.");
        //        Console.ReadLine();
        //        return;
        //    }


        //    // --- Run Scheduler ---
        //    // Consider adjusting population size based on performance/memory
        //    GeneticAlgorithm ds = new GeneticAlgorithm(300, Doctors, Patients);
        //    Console.WriteLine("Running scheduling algorithm...");
        //    Schedule finalSchedule = ds.Solve();
        //    Console.WriteLine("Algorithm finished.");

        //    // --- Update Singleton Data (Optional but recommended if data is reused) ---
        //    Console.WriteLine("Updating singleton data based on final schedule...");
        //    //await UpdateSingeletonData(finalSchedule);


        //    // --- Write Logs ---



        //    // --- Analyze & Display Results ---
        //    if (finalSchedule == null)
        //    {
        //        Console.WriteLine("\nERROR: Final schedule generated by algorithm is null.");
        //    }
        //    else
        //    {
        //        Console.WriteLine("\n--- Schedule Summary ---");
        //        int totalSchedulablePatients = Patients.Count(p => !p.NeedsSurgery);
        //        // Use the schedule's lookup for accurate count of assigned patients
        //        int assignedCount = finalSchedule.PatientAssignmentLookup.Count;
        //        double assignmentRate = totalSchedulablePatients > 0 ? ((double)assignedCount / totalSchedulablePatients * 100) : 0;

        //        Console.WriteLine($"Final Fitness Score: {finalSchedule.FitnessScore:F2}");
        //        Console.WriteLine($"Assigned Patients (Non-Surgery): {assignedCount} / {totalSchedulablePatients} ({assignmentRate:F1}%)");

        //        // --- Print Scheduled Appointments ---
        //        Console.WriteLine("\n--- Scheduled Appointments (Grouped by Doctor) ---");
        //        if (finalSchedule.Appointments.Any())
        //        {
        //            // Group by Doctor for readability
        //            var groupedSchedule = finalSchedule.Appointments
        //                                   .OrderBy(a => a.DoctorId) // Sort primarily by Doctor ID
        //                                   .ThenBy(a => (int)a.DayOfWeek) // Then by Day (ensure correct numerical order)
        //                                   .ThenBy(a => a.StartTime)    // Then by Time
        //                                   .GroupBy(a => a.DoctorId);

        //            foreach (var group in groupedSchedule)
        //            {
        //                Doctor doc = Doctors.FirstOrDefault(d => d.Id == group.Key);
        //                Console.WriteLine($"\n-- Dr. {doc?.Name ?? "Unknown"} (ID: {group.Key}, Load: {group.Count()}/{doc?.MaxWorkload ?? 0}) --"); // Show workload
        //                foreach (var appt in group) // Appointments are already sorted within the group by LINQ
        //                {
        //                    Patient pati = Patients.FirstOrDefault(p => p.Id == appt.PatientId);
        //                    // Display Day, Start, End, Duration, Patient ID, Patient Name
        //                    Console.WriteLine($"  {appt.DayOfWeek,-9} {appt.StartTime:hh\\:mm} - {appt.EndTime:hh\\:mm} (Dur: {appt.Duration.TotalMinutes:F0}m) : P{appt.PatientId,-4} ({pati?.Name ?? "Unknown"})");
        //                }
        //            }
        //        }
        //        else
        //        {
        //            Console.WriteLine("No appointments were scheduled.");
        //        }

        //        // --- List Unassigned Patients ---
        //        Console.WriteLine("\n--- Unassigned Patients (Non-Surgery) ---");
        //        // Find patients not in the final schedule's lookup
        //        List<Patient> unassignedPatients = Patients
        //            .Where(p => !p.NeedsSurgery && !finalSchedule.PatientAssignmentLookup.ContainsKey(p.Id))
        //            .OrderByDescending(p => p.Urgency).ThenByDescending(p => p.ComplexityLevel) // Order by priority
        //            .ToList();

        //        if (unassignedPatients.Any())
        //        {
        //            foreach (var p in unassignedPatients)
        //            {
        //                Console.WriteLine($"- P{p.Id}: {p.Name} (Urg: {p.Urgency}, Complex: {p.ComplexityLevel}, Spec: {p.RequiredSpecialization})");
        //            }
        //            ;
        //        }
        //        else
        //        {
        //            Console.WriteLine("All non-surgery patients were assigned.");
        //        }
        //    }

        //    // --- Remove Old Analysis Section ---
        //    // The old FindWhyPatientWasntAssinged is no longer accurate as it doesn't check slots/time.
        //    // Rely on the diagnostic logs and the summary above.
        //    // List<Patient> LoserPatients = ...
        //    // LoserPatients.ForEach(D => FindWhyPatientWasntAssinged(D));


        //    Console.WriteLine("\nPress Enter to exit.");
        //    Console.ReadLine();
        //}
    }
    }
